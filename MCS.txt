PN Sequence Generator ðŸ‘‡


t = [1, 1, 0, 1]; % Initialize the array

x1 = t(1); % Assign values from the array (note: Octave/Matlab indexing starts at 1)
x2 = t(2);
x3 = t(3);
x4 = t(4);

for i = 0:15
    u1 = bitxor(x3, x4); % XOR operation in Octave/Matlab
    x4 = x3;
    x3 = x2;
    x2 = x1;
    x1 = u1;
    fprintf('%d', u1); % Print the result
end
fprintf('\n\n'); % Print newline


_________________________________________________________________________________________________________________


CDMAðŸ‘‡

ak = [-1, 1, -1, -1, 1, 1]; % Initialize the array
bk = [1, 1, -1, 1, -1, 1];

a = 1;
b = uint32(-1); % Use uint32 for unsigned integer
as = zeros(1, 6); % Preallocate arrays
bs = zeros(1, 6);
cs = zeros(1, 6);
ds = zeros(1, 6);

% Calculate as
for i = 1:6
    as(i) = ak(i) * a;
    fprintf('%d', as(i)); % Print the result
end
fprintf('\n');

% Calculate bs
for j = 1:6
    bs(j) = bk(j) * b;
    fprintf('%d', bs(j)); % Print the result
end
fprintf('\n');

% Calculate cs
for k = 1:6
    cs(k) = as(k) + bs(k);
    fprintf('%d', cs(k)); % Corrected to print cs[k]
end
fprintf('\n');

% Calculate ds
for k = 1:6
    ds(k) = cs(k) * bk(k);
    fprintf('%d', ds(k)); % Print the result
end
fprintf('\n');

% Sum of ds
e = sum(ds);
fprintf('%d', e); % Print the sum

fprintf('\n');
if e <= 0
    fprintf('0 is transmitted\n');
else
    fprintf('1 is transmitted\n');
end

fprintf('\n');


_________________________________________________________________________________________________________________


Convolution 


t = [1, 0, 1, 0, 0]; % Initialize the array
x1 = 0;
x2 = 0;
x3 = 0;

for i = 1:5 % Loop through the array (1-based indexing)
    x1 = t(i); % Get the current value
    u1 = bitxor(bitxor(x1, x2), x3); % XOR operation for u1
    u2 = bitxor(x1, x3); % XOR operation for u2
    fprintf('%d', u1); % Print u1
    fprintf('%d', u2); % Print u2
    x3 = x2; % Update x3
    x2 = x1; % Update x2
end

_________________________________________________________________________________________________________________


Walshe Matrix


clear
N = 4;

hadamardMatrix = hadamard(N);
HadIdx = 0:N-1;

M = log2(N)+1;
binHadIdx = fliplr(dec2bin(HadIdx, M)-'0');

binSeqIdx = zeros(N, M-1);
for k = M-1:-1:2
    binSeqIdx(:, k) = xor(binHadIdx(:, k), binHadIdx(:, k-1));
end

SeqIdx = binSeqIdx*pow2((M-2:-1:0)');
walshMatrix = hadamardMatrix(SeqIdx+1, :);


disp('hadamard Matrix:');
disp(hadamardMatrix);

disp('M=:');
disp(M);

disp('Walsh Matrix:');
disp(walshMatrix);


_________________________________________________________________________________________________________________


Ciratio

num_clusters = 7;
snr_db = [0, 5, 10, 15, 20];
num_samples = 100;

cluster_sizes = zeros(length(snr_db), num_clusters);
voice_quality_scores = zeros(length(snr_db), 1);

function quality = simulate_voice_quality(snr)
    quality = max(0, min(100, 10*snr));
end

for i = 1:length(snr_db)
    for j = 1:num_clusters
        noise = randn(num_samples, 1) * (10 / snr_db(i));
        cluster_data = randn(num_samples, 1) + noise;
        cluster_sizes(i, j) = length(cluster_data);
    end

    voice_quality_scores(i) = simulate_voice_quality(snr_db(i));
end

disp('Cluster Sizes for Different SNR Levels:');
disp(cluster_sizes);

disp('Voice Quality Scores for Different SNR Levels:');
disp(voice_quality_scores);

figure;
subplot(2, 1, 1);
bar(cluster_sizes);
xlabel('SNR (dB)');
ylabel('Cluster Size');
title('Cluster Sizes vs SNR');
legend(arrayfun(@(x) sprintf('Cluster %d', x), 1:num_clusters, 'UniformOutput', false));

subplot(2, 1, 2);
plot(snr_db, voice_quality_scores, 'o-');
xlabel('SNR (dB)');
ylabel('Voice Quality Score');
title('Voice Quality vs SNR');
grid on;


_________________________________________________________________________________________________________________




